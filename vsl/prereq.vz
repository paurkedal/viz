# Copyright 2011  Petter Urkedal
#
# This file is part of the Viz Standard Library <http://www.vizlang.org/>.
#
# The Viz Standard Library (VSL) is free software: you can redistribute it
# and/or modify it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# The VSL is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with the VSL.  If not, see <http://www.gnu.org/licenses/>.

#?ffoc include compat.ocaml_prereq
#?ffoc include compat.ocaml_unicode.pervasive
#?ffoc include compat.ocaml_pervasives.pervasive

in combinators
    let ident x be x
    let konst x y be x
    let (g <* f) x be g (f x)  # also g ∘ f
    let (f *> g) x be g (f x)
    let f <| x be f x  # f "at" x
    let x |> f be f x  # x "under" f

in basics
    type line_location := string * int
    inj failure : line_location → string → exception

    let fst (x, _) be x
    let snd (_, y) be y

    sig a_total_order
	type t
	val cmp : t → t → torder

    in total_order_ops.(Ord : a_total_order)
	let x = y be (tcoin% ↦ true; _ ↦ false) (Ord.cmp x y)
	let x ≠ y be (tcoin% ↦ false; _ ↦ true) (Ord.cmp x y)
	let x ≤ y be (tsucc% ↦ false; _ ↦ true) (Ord.cmp x y)
	let x ≥ y be (tprec% ↦ false; _ ↦ true) (Ord.cmp x y)
	let x < y be (tprec% ↦ true; _ ↦ false) (Ord.cmp x y)
	let x > y be (tsucc% ↦ true; _ ↦ false) (Ord.cmp x y)
open basics

in bool_ops
    #?ffoc include compat.ocaml_pervasives.bool_ops
    let (¬* f)   x0 be ¬ f x0
    let (f ∧* g) x0 be f x0 ∧ g x0
    let (f ∨* g) x0 be f x0 ∨ g x0
    let (¬** f)   x0 x1 be ¬ f x0 x1
    let (f ∧** g) x0 x1 be f x0 x1 ∧ g x0 x1
    let (f ∨** g) x0 x1 be f x0 x1 ∨ g x0 x1

sig a_basic_nat
    type t

    val eq : t → t → bool
    val cmp : t → t → torder
    val 2'≤ : t → t → bool
    val 2'≥ : t → t → bool
    val 2'< : t → t → bool
    val 2'> : t → t → bool

    val width : int
    val zero : t
    val one : t

    val add : t → t → t
    val sub : t → t → t
    val mul : t → t → t
    val 0'div : t → t → t
    val 0'mod : t → t → t
    val 0'quo : t → t → t
    val 0'rem : t → t → t

    val bitnot : t → t
    val bitand : t → t → t
    val bitor : t → t → t
    val bitxor : t → t → t
    val shift : int → t → t
    val of_int : int → t
    val as_int : t → int

sig a_basic_int
    include a_basic_nat

    val neg : t → t
    val abs : t → t

in nat_ops.(Nat : a_basic_nat)
    let 1'+ (x : Nat.t) be x
    let 2'+ be Nat.add
    let 2'− be Nat.sub
    let 2'× be Nat.mul
    let 2'div be Nat.div
    let 2'mod be Nat.mod
    let 2'quo be Nat.quo
    let 2'rem be Nat.rem

in int_ops.(Int : a_basic_int)
    include nat_ops.(Int)
    let 1'− be Int.neg

in extend_basic_int_or_nat.(Nat : a_basic_nat)
    open compat.ocaml_miscints
    open Nat

    let min x y be x ≤ y ⇒ x; y
    let max x y be x ≤ y ⇒ y; x

    let floor_log2 x
	let f iL width
	    if int.eq width 1 be iL
	    let halfwidth be int.shift -1 width
	    let iM be int.add iL halfwidth
	    be f iL halfwidth if eq zero (shift (int.neg iM) x)
	    be f iM (int.sub width halfwidth) otherwise
	if x <= zero fail "Non-positive value passed to floor_log2."
	be f 0 width

in extend_basic_nat.(Nat : a_basic_nat)
    include extend_basic_int_or_nat.(Nat)
    in ops include nat_ops.(Nat)
    open ops
    let cdiv x y be (x + y - Nat.one) div y

in extend_basic_int.(Int : a_basic_int)
    include extend_basic_int_or_nat.(Int)
    in ops include int_ops.(Int)
    open ops
    let cdiv x y be - x div (- y)
    let cmod x y be   x mod (- y)

in int
    #?ffoc include compat.ocaml_miscints.int
    #?ffoc include extend_basic_int.(compat.ocaml_miscints.int)
    #?ffoc include compat.ocaml_pervasives.int_misc
in nint
    #?ffoc include compat.ocaml_miscints.nint
    #?ffoc include extend_basic_int.(compat.ocaml_miscints.nint)
in int32
    #?ffoc include compat.ocaml_miscints.int32
    #?ffoc include extend_basic_int.(compat.ocaml_miscints.int32)
in int64
    #?ffoc include compat.ocaml_miscints.int64
    #?ffoc include extend_basic_int.(compat.ocaml_miscints.int64)
in nat32
    #?ffoc include compat.ocaml_miscints.nat32
    #?ffoc include extend_basic_nat.(compat.ocaml_miscints.nat32)
in nat64
    #?ffoc include compat.ocaml_miscints.nat64
    #?ffoc include extend_basic_nat.(compat.ocaml_miscints.nat64)

in effect
    type φ /~ α := effect φ α
    val return : α → effect φ α
    val 2'>>= : effect φ α → (α → effect φ β) → effect φ β
    val 2'>> : effect φ unit → effect φ α → effect φ α
    val observe : (∀ψ. effect ψ α) → α
    val unsafe_observe : effect ψ α → α

    type pocket_tag φ  inj pocket_tag : pocket_tag φ

    let return be __builtin_effect_return
    let 2'>>= m k be __builtin_effect_bind k m
    let 2'>> m n be __builtin_effect_bind (() +> n) m
    let observe (m : ∀ψ. effect ψ α) be __builtin_effect_run m
    let unsafe_observe be __builtin_effect_run

in effect_pervasive
    open effect

    let __builtin_toplevel_run m be __builtin_effect_run what!
	upon failure (p, l) msg
	    do print p >> print ":" >> print (int.show l)
	    do print ": failure: " >> print msg >> print "\n"
	    do flush stdout
	    do __builtin_exit 69
	do m

# This is for our own use, as we typically open prereq on the top of each
# library structure.  The pervasive structure does a similar inclusion for
# client code.
include basics
include combinators
include bool_ops
include int.ops
include effect_pervasive
#?ffoc include compat.ocaml_miscints.pervasive
